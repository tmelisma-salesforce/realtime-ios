// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pubsub_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Salesforce Pub/Sub API Version 1.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Supported error codes
enum Eventbus_V1_ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case publish // = 1

  /// ErrorCode for unrecoverable commit errors.
  case commit // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .publish
    case 2: self = .commit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .publish: return 1
    case .commit: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eventbus_V1_ErrorCode] = [
    .unknown,
    .publish,
    .commit,
  ]

}

///
/// Supported subscription replay start values.
/// By default, the subscription will start at the tip of the stream if ReplayPreset is not specified.
enum Eventbus_V1_ReplayPreset: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Start the subscription at the tip of the stream.
  case latest // = 0

  /// Start the subscription at the earliest point in the stream.
  case earliest // = 1

  /// Start the subscription after a custom point in the stream. This must be set with a valid replay_id in the FetchRequest.
  case custom // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .latest
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .latest
    case 1: self = .earliest
    case 2: self = .custom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .latest: return 0
    case .earliest: return 1
    case .custom: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eventbus_V1_ReplayPreset] = [
    .latest,
    .earliest,
    .custom,
  ]

}

///
/// Contains information about a topic and uniquely identifies it. TopicInfo is returned by the GetTopic RPC method.
struct Eventbus_V1_TopicInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Topic name
  var topicName: String = String()

  /// Tenant/org GUID
  var tenantGuid: String = String()

  /// Is publishing allowed?
  var canPublish: Bool = false

  /// Is subscription allowed?
  var canSubscribe: Bool = false

  /// ID of the current topic schema, which can be used for
  /// publishing of generically serialized events.
  var schemaID: String = String()

  /// RPC ID used to trace errors.
  var rpcID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A request message for GetTopic. Note that the tenant/org is not directly referenced
/// in the request, but is implicitly identified by the authentication headers.
struct Eventbus_V1_TopicRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the topic to retrieve.
  var topicName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Reserved for future use.
/// Header that contains information for distributed tracing, filtering, routing, etc.
/// For example, X-B3-* headers assigned by a publisher are stored with the event and
/// can provide a full distributed trace of the event across its entire lifecycle.
struct Eventbus_V1_EventHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Represents an event that an event publishing app creates.
struct Eventbus_V1_ProducerEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Either a user-provided ID or a system generated guid
  var id: String = String()

  /// Schema fingerprint for this event which is hash of the schema
  var schemaID: String = String()

  /// The message data field
  var payload: Data = Data()

  /// Reserved for future use. Key-value pairs of headers.
  var headers: [Eventbus_V1_EventHeader] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Represents an event that is consumed in a subscriber client.
/// In addition to the fields in ProducerEvent, ConsumerEvent has the replay_id field.
struct Eventbus_V1_ConsumerEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event with fields identical to ProducerEvent
  var event: Eventbus_V1_ProducerEvent {
    get {return _event ?? Eventbus_V1_ProducerEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  /// The replay ID of the event.
  /// A subscriber app can store the replay ID. When the app restarts, it can resume subscription
  /// starting from events in the event bus after the event with that replay ID.
  var replayID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _event: Eventbus_V1_ProducerEvent? = nil
}

///
/// Event publish result that the Publish RPC method returns. The result contains replay_id or a publish error.
struct Eventbus_V1_PublishResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Replay ID of the event
  var replayID: Data = Data()

  /// Publish error if any
  var error: Eventbus_V1_Error {
    get {return _error ?? Eventbus_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  /// Correlation key of the ProducerEvent
  var correlationKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Eventbus_V1_Error? = nil
}

/// Contains error information for an error that an RPC method returns.
struct Eventbus_V1_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code
  var code: Eventbus_V1_ErrorCode = .unknown

  /// Error message
  var msg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Request for the Subscribe streaming RPC method. This request is used to:
/// 1. Establish the initial subscribe stream.
/// 2. Request more events from the subscription stream.
/// Flow Control is handled by the subscriber via num_requested.
/// A client can specify a starting point for the subscription with replay_preset and replay_id combinations.
/// If no replay_preset is specified, the subscription starts at LATEST (tip of the stream).
/// replay_preset and replay_id values are only consumed as part of the first FetchRequest. If
/// a client needs to start at another point in the stream, it must start a new subscription.
struct Eventbus_V1_FetchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Identifies a topic for subscription in the very first FetchRequest of the stream. The topic cannot change
  /// in subsequent FetchRequests within the same subscribe stream, but can be omitted for efficiency.
  var topicName: String = String()

  ///
  /// Subscription starting point. This is consumed only as part of the first FetchRequest
  /// when the subscription is set up.
  var replayPreset: Eventbus_V1_ReplayPreset = .latest

  ///
  /// If replay_preset of CUSTOM is selected, specify the subscription point to start after.
  /// This is consumed only as part of the first FetchRequest when the subscription is set up.
  var replayID: Data = Data()

  ///
  /// Number of events a client is ready to accept. Each subsequent FetchRequest informs the server
  /// of additional processing capacity available on the client side. There is no guarantee of equal number of
  /// FetchResponse messages to be sent back. There is not necessarily a correspondence between
  /// number of requested events in FetchRequest and the number of events returned in subsequent
  /// FetchResponses.
  var numRequested: Int32 = 0

  /// For internal Salesforce use only.
  var authRefresh: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Response for the Subscribe streaming RPC method. This returns ConsumerEvent(s).
/// If there are no events to deliver, the server sends an empty batch fetch response with the latest replay ID. The
/// empty fetch response is sent within 270 seconds. An empty fetch response provides a periodic keepalive from the
/// server and the latest replay ID.
struct Eventbus_V1_FetchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received events for subscription for client consumption
  var events: [Eventbus_V1_ConsumerEvent] = []

  /// Latest replay ID of a subscription. Enables clients with an updated replay value so that they can keep track
  /// of their last consumed replay. Clients will not have to start a subscription at a very old replay in the case where a resubscribe is necessary.
  var latestReplayID: Data = Data()

  /// RPC ID used to trace errors.
  var rpcID: String = String()

  /// Number of remaining events to be delivered to the client for a Subscribe RPC call.
  var pendingNumRequested: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Request for the GetSchema RPC method. The schema request is based on the event schema ID.
struct Eventbus_V1_SchemaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Schema fingerprint for this event, which is a hash of the schema.
  var schemaID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Response for the GetSchema RPC method. This returns the schema ID and schema of an event.
struct Eventbus_V1_SchemaInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Avro schema in JSON format
  var schemaJson: String = String()

  /// Schema fingerprint
  var schemaID: String = String()

  /// RPC ID used to trace errors.
  var rpcID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the Publish and PublishStream RPC method.
struct Eventbus_V1_PublishRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Topic to publish on
  var topicName: String = String()

  /// Batch of ProducerEvent(s) to send
  var events: [Eventbus_V1_ProducerEvent] = []

  /// For internal Salesforce use only.
  var authRefresh: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Response for the Publish and PublishStream RPC methods. This returns
/// a list of PublishResults for each event that the client attempted to
/// publish. PublishResult indicates if publish succeeded or not
/// for each event. It also returns the schema ID that was used to create
/// the ProducerEvents in the PublishRequest.
struct Eventbus_V1_PublishResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Publish results
  var results: [Eventbus_V1_PublishResult] = []

  /// Schema fingerprint for this event, which is a hash of the schema
  var schemaID: String = String()

  /// RPC ID used to trace errors.
  var rpcID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// This feature is part of an open beta release and is subject to the applicable
/// Beta Services Terms provided at Agreements and Terms
/// (https://www.salesforce.com/company/legal/agreements/).
///
/// Request for the ManagedSubscribe streaming RPC method. This request is used to:
/// 1. Establish the initial managed subscribe stream.
/// 2. Request more events from the subscription stream.
/// 3. Commit a Replay ID using CommitReplayRequest.
struct Eventbus_V1_ManagedFetchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Managed subscription ID or developer name. This value corresponds to the
  /// ID or developer name of the ManagedEventSubscription Tooling API record.
  /// This value is consumed as part of the first ManagedFetchRequest only.
  /// The subscription_id cannot change in subsequent ManagedFetchRequests
  /// within the same subscribe stream, but can be omitted for efficiency.
  var subscriptionID: String = String()

  var developerName: String = String()

  ///
  /// Number of events a client is ready to accept. Each subsequent FetchRequest informs the server
  /// of additional processing capacity available on the client side. There is no guarantee of equal number of
  /// FetchResponse messages to be sent back. There is not necessarily a correspondence between
  /// number of requested events in FetchRequest and the number of events returned in subsequent
  /// FetchResponses.
  var numRequested: Int32 = 0

  /// For internal Salesforce use only.
  var authRefresh: String = String()

  var commitReplayIDRequest: Eventbus_V1_CommitReplayRequest {
    get {return _commitReplayIDRequest ?? Eventbus_V1_CommitReplayRequest()}
    set {_commitReplayIDRequest = newValue}
  }
  /// Returns true if `commitReplayIDRequest` has been explicitly set.
  var hasCommitReplayIDRequest: Bool {return self._commitReplayIDRequest != nil}
  /// Clears the value of `commitReplayIDRequest`. Subsequent reads from it will return its default value.
  mutating func clearCommitReplayIDRequest() {self._commitReplayIDRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commitReplayIDRequest: Eventbus_V1_CommitReplayRequest? = nil
}

///
/// This feature is part of an open beta release and is subject to the applicable
/// Beta Services Terms provided at Agreements and Terms
/// (https://www.salesforce.com/company/legal/agreements/).
///
/// Response for the ManagedSubscribe streaming RPC method. This can return
/// ConsumerEvent(s) or CommitReplayResponse along with other metadata.
struct Eventbus_V1_ManagedFetchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received events for subscription for client consumption
  var events: [Eventbus_V1_ConsumerEvent] = []

  /// Latest replay ID of a subscription.
  var latestReplayID: Data = Data()

  /// RPC ID used to trace errors.
  var rpcID: String = String()

  /// Number of remaining events to be delivered to the client for a Subscribe RPC call.
  var pendingNumRequested: Int32 = 0

  /// commit response
  var commitResponse: Eventbus_V1_CommitReplayResponse {
    get {return _commitResponse ?? Eventbus_V1_CommitReplayResponse()}
    set {_commitResponse = newValue}
  }
  /// Returns true if `commitResponse` has been explicitly set.
  var hasCommitResponse: Bool {return self._commitResponse != nil}
  /// Clears the value of `commitResponse`. Subsequent reads from it will return its default value.
  mutating func clearCommitResponse() {self._commitResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commitResponse: Eventbus_V1_CommitReplayResponse? = nil
}

///
/// This feature is part of an open beta release and is subject to the applicable
/// Beta Services Terms provided at Agreements and Terms
/// (https://www.salesforce.com/company/legal/agreements/).
///
/// Request to commit a Replay ID for the last processed event or for the latest
/// replay ID received in an empty batch of events.
struct Eventbus_V1_CommitReplayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// commit_request_id to identify commit responses
  var commitRequestID: String = String()

  /// replayId to commit
  var replayID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// This feature is part of an open beta release and is subject to the applicable
/// Beta Services Terms provided at Agreements and Terms
/// (https://www.salesforce.com/company/legal/agreements/).
///
/// There is no guaranteed 1:1 CommitReplayRequest to CommitReplayResponse.
/// N CommitReplayRequest(s) can get compressed in a batch resulting in a single
/// CommitReplayResponse which reflects the latest values of last
/// CommitReplayRequest in that batch.
struct Eventbus_V1_CommitReplayResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// commit_request_id to identify commit responses.
  var commitRequestID: String = String()

  /// replayId that may have been committed
  var replayID: Data = Data()

  /// for failed commits
  var error: Eventbus_V1_Error {
    get {return _error ?? Eventbus_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  /// time when server received request in epoch ms
  var processTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Eventbus_V1_Error? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "eventbus.v1"

extension Eventbus_V1_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}PUBLISH\0\u{1}COMMIT\0")
}

extension Eventbus_V1_ReplayPreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LATEST\0\u{1}EARLIEST\0\u{1}CUSTOM\0")
}

extension Eventbus_V1_TopicInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}topic_name\0\u{3}tenant_guid\0\u{3}can_publish\0\u{3}can_subscribe\0\u{3}schema_id\0\u{3}rpc_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tenantGuid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canPublish) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canSubscribe) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.schemaID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rpcID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 1)
    }
    if !self.tenantGuid.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantGuid, fieldNumber: 2)
    }
    if self.canPublish != false {
      try visitor.visitSingularBoolField(value: self.canPublish, fieldNumber: 3)
    }
    if self.canSubscribe != false {
      try visitor.visitSingularBoolField(value: self.canSubscribe, fieldNumber: 4)
    }
    if !self.schemaID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaID, fieldNumber: 5)
    }
    if !self.rpcID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_TopicInfo, rhs: Eventbus_V1_TopicInfo) -> Bool {
    if lhs.topicName != rhs.topicName {return false}
    if lhs.tenantGuid != rhs.tenantGuid {return false}
    if lhs.canPublish != rhs.canPublish {return false}
    if lhs.canSubscribe != rhs.canSubscribe {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.rpcID != rhs.rpcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_TopicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}topic_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_TopicRequest, rhs: Eventbus_V1_TopicRequest) -> Bool {
    if lhs.topicName != rhs.topicName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_EventHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventHeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_EventHeader, rhs: Eventbus_V1_EventHeader) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_ProducerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProducerEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}schema_id\0\u{1}payload\0\u{1}headers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.schemaID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaID, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_ProducerEvent, rhs: Eventbus_V1_ProducerEvent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_ConsumerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumerEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}event\0\u{3}replay_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.replayID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.replayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.replayID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_ConsumerEvent, rhs: Eventbus_V1_ConsumerEvent) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.replayID != rhs.replayID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_PublishResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}replay_id\0\u{1}error\0\u{3}correlation_key\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.replayID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.correlationKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.replayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.replayID, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.correlationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.correlationKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_PublishResult, rhs: Eventbus_V1_PublishResult) -> Bool {
    if lhs.replayID != rhs.replayID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.correlationKey != rhs.correlationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_Error, rhs: Eventbus_V1_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_FetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}topic_name\0\u{3}replay_preset\0\u{3}replay_id\0\u{3}num_requested\0\u{3}auth_refresh\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.replayPreset) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.replayID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numRequested) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authRefresh) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 1)
    }
    if self.replayPreset != .latest {
      try visitor.visitSingularEnumField(value: self.replayPreset, fieldNumber: 2)
    }
    if !self.replayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.replayID, fieldNumber: 3)
    }
    if self.numRequested != 0 {
      try visitor.visitSingularInt32Field(value: self.numRequested, fieldNumber: 4)
    }
    if !self.authRefresh.isEmpty {
      try visitor.visitSingularStringField(value: self.authRefresh, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_FetchRequest, rhs: Eventbus_V1_FetchRequest) -> Bool {
    if lhs.topicName != rhs.topicName {return false}
    if lhs.replayPreset != rhs.replayPreset {return false}
    if lhs.replayID != rhs.replayID {return false}
    if lhs.numRequested != rhs.numRequested {return false}
    if lhs.authRefresh != rhs.authRefresh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_FetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}events\0\u{3}latest_replay_id\0\u{3}rpc_id\0\u{3}pending_num_requested\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.latestReplayID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rpcID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pendingNumRequested) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.latestReplayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.latestReplayID, fieldNumber: 2)
    }
    if !self.rpcID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcID, fieldNumber: 3)
    }
    if self.pendingNumRequested != 0 {
      try visitor.visitSingularInt32Field(value: self.pendingNumRequested, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_FetchResponse, rhs: Eventbus_V1_FetchResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.latestReplayID != rhs.latestReplayID {return false}
    if lhs.rpcID != rhs.rpcID {return false}
    if lhs.pendingNumRequested != rhs.pendingNumRequested {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_SchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SchemaRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_SchemaRequest, rhs: Eventbus_V1_SchemaRequest) -> Bool {
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_SchemaInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SchemaInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_json\0\u{3}schema_id\0\u{3}rpc_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaJson) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rpcID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaJson.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaJson, fieldNumber: 1)
    }
    if !self.schemaID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaID, fieldNumber: 2)
    }
    if !self.rpcID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_SchemaInfo, rhs: Eventbus_V1_SchemaInfo) -> Bool {
    if lhs.schemaJson != rhs.schemaJson {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.rpcID != rhs.rpcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}topic_name\0\u{1}events\0\u{3}auth_refresh\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authRefresh) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    if !self.authRefresh.isEmpty {
      try visitor.visitSingularStringField(value: self.authRefresh, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_PublishRequest, rhs: Eventbus_V1_PublishRequest) -> Bool {
    if lhs.topicName != rhs.topicName {return false}
    if lhs.events != rhs.events {return false}
    if lhs.authRefresh != rhs.authRefresh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}results\0\u{3}schema_id\0\u{3}rpc_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rpcID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.schemaID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaID, fieldNumber: 2)
    }
    if !self.rpcID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_PublishResponse, rhs: Eventbus_V1_PublishResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.rpcID != rhs.rpcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_ManagedFetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagedFetchRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}subscription_id\0\u{3}developer_name\0\u{3}num_requested\0\u{3}auth_refresh\0\u{3}commit_replay_id_request\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.developerName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numRequested) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authRefresh) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._commitReplayIDRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    if !self.developerName.isEmpty {
      try visitor.visitSingularStringField(value: self.developerName, fieldNumber: 2)
    }
    if self.numRequested != 0 {
      try visitor.visitSingularInt32Field(value: self.numRequested, fieldNumber: 3)
    }
    if !self.authRefresh.isEmpty {
      try visitor.visitSingularStringField(value: self.authRefresh, fieldNumber: 4)
    }
    try { if let v = self._commitReplayIDRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_ManagedFetchRequest, rhs: Eventbus_V1_ManagedFetchRequest) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.developerName != rhs.developerName {return false}
    if lhs.numRequested != rhs.numRequested {return false}
    if lhs.authRefresh != rhs.authRefresh {return false}
    if lhs._commitReplayIDRequest != rhs._commitReplayIDRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_ManagedFetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagedFetchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}events\0\u{3}latest_replay_id\0\u{3}rpc_id\0\u{3}pending_num_requested\0\u{3}commit_response\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.latestReplayID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rpcID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pendingNumRequested) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._commitResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.latestReplayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.latestReplayID, fieldNumber: 2)
    }
    if !self.rpcID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpcID, fieldNumber: 3)
    }
    if self.pendingNumRequested != 0 {
      try visitor.visitSingularInt32Field(value: self.pendingNumRequested, fieldNumber: 4)
    }
    try { if let v = self._commitResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_ManagedFetchResponse, rhs: Eventbus_V1_ManagedFetchResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.latestReplayID != rhs.latestReplayID {return false}
    if lhs.rpcID != rhs.rpcID {return false}
    if lhs.pendingNumRequested != rhs.pendingNumRequested {return false}
    if lhs._commitResponse != rhs._commitResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_CommitReplayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitReplayRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}commit_request_id\0\u{3}replay_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commitRequestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.replayID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commitRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.commitRequestID, fieldNumber: 1)
    }
    if !self.replayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.replayID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_CommitReplayRequest, rhs: Eventbus_V1_CommitReplayRequest) -> Bool {
    if lhs.commitRequestID != rhs.commitRequestID {return false}
    if lhs.replayID != rhs.replayID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventbus_V1_CommitReplayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitReplayResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}commit_request_id\0\u{3}replay_id\0\u{1}error\0\u{3}process_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commitRequestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.replayID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.processTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.commitRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.commitRequestID, fieldNumber: 1)
    }
    if !self.replayID.isEmpty {
      try visitor.visitSingularBytesField(value: self.replayID, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.processTime != 0 {
      try visitor.visitSingularInt64Field(value: self.processTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eventbus_V1_CommitReplayResponse, rhs: Eventbus_V1_CommitReplayResponse) -> Bool {
    if lhs.commitRequestID != rhs.commitRequestID {return false}
    if lhs.replayID != rhs.replayID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.processTime != rhs.processTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
