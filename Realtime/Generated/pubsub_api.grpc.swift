//
// Salesforce Pub/Sub API Version 1.

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: pubsub_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

// MARK: - eventbus.v1.PubSub

/// Namespace containing generated types for the "eventbus.v1.PubSub" service.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal enum Eventbus_V1_PubSub {
    /// Service descriptor for the "eventbus.v1.PubSub" service.
    internal static let descriptor = GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub")
    /// Namespace for method metadata.
    internal enum Method {
        /// Namespace for "Subscribe" metadata.
        internal enum Subscribe {
            /// Request type for "Subscribe".
            internal typealias Input = Eventbus_V1_FetchRequest
            /// Response type for "Subscribe".
            internal typealias Output = Eventbus_V1_FetchResponse
            /// Descriptor for "Subscribe".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "Subscribe"
            )
        }
        /// Namespace for "GetSchema" metadata.
        internal enum GetSchema {
            /// Request type for "GetSchema".
            internal typealias Input = Eventbus_V1_SchemaRequest
            /// Response type for "GetSchema".
            internal typealias Output = Eventbus_V1_SchemaInfo
            /// Descriptor for "GetSchema".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "GetSchema"
            )
        }
        /// Namespace for "GetTopic" metadata.
        internal enum GetTopic {
            /// Request type for "GetTopic".
            internal typealias Input = Eventbus_V1_TopicRequest
            /// Response type for "GetTopic".
            internal typealias Output = Eventbus_V1_TopicInfo
            /// Descriptor for "GetTopic".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "GetTopic"
            )
        }
        /// Namespace for "Publish" metadata.
        internal enum Publish {
            /// Request type for "Publish".
            internal typealias Input = Eventbus_V1_PublishRequest
            /// Response type for "Publish".
            internal typealias Output = Eventbus_V1_PublishResponse
            /// Descriptor for "Publish".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "Publish"
            )
        }
        /// Namespace for "PublishStream" metadata.
        internal enum PublishStream {
            /// Request type for "PublishStream".
            internal typealias Input = Eventbus_V1_PublishRequest
            /// Response type for "PublishStream".
            internal typealias Output = Eventbus_V1_PublishResponse
            /// Descriptor for "PublishStream".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "PublishStream"
            )
        }
        /// Namespace for "ManagedSubscribe" metadata.
        internal enum ManagedSubscribe {
            /// Request type for "ManagedSubscribe".
            internal typealias Input = Eventbus_V1_ManagedFetchRequest
            /// Response type for "ManagedSubscribe".
            internal typealias Output = Eventbus_V1_ManagedFetchResponse
            /// Descriptor for "ManagedSubscribe".
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub"),
                method: "ManagedSubscribe"
            )
        }
        /// Descriptors for all methods in the "eventbus.v1.PubSub" service.
        internal static let descriptors: [GRPCCore.MethodDescriptor] = [
            Subscribe.descriptor,
            GetSchema.descriptor,
            GetTopic.descriptor,
            Publish.descriptor,
            PublishStream.descriptor,
            ManagedSubscribe.descriptor
        ]
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension GRPCCore.ServiceDescriptor {
    /// Service descriptor for the "eventbus.v1.PubSub" service.
    internal static let eventbus_v1_PubSub = GRPCCore.ServiceDescriptor(fullyQualifiedService: "eventbus.v1.PubSub")
}

// MARK: eventbus.v1.PubSub (client)

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Eventbus_V1_PubSub {
    /// Generated client protocol for the "eventbus.v1.PubSub" service.
    ///
    /// You don't need to implement this protocol directly, use the generated
    /// implementation, ``Client``.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > The Pub/Sub API provides a single interface for publishing and subscribing to platform events, including real-time
    /// > event monitoring events, and change data capture events. The Pub/Sub API is a gRPC API that is based on HTTP/2.
    /// > 
    /// > A session token is needed to authenticate. Any of the Salesforce supported
    /// > OAuth flows can be used to obtain a session token:
    /// > https://help.salesforce.com/articleView?id=sf.remoteaccess_oauth_flows.htm&type=5
    /// > 
    /// > For each RPC, a client needs to pass authentication information
    /// > as metadata headers (https://www.grpc.io/docs/guides/concepts/#metadata) with their method call.
    /// > 
    /// > For Salesforce session token authentication, use:
    /// >   accesstoken : access token
    /// >   instanceurl : Salesforce instance URL
    /// >   tenantid : tenant/org id of the client
    /// > 
    /// > StatusException is thrown in case of response failure for any request.
    internal protocol ClientProtocol: Sendable {
        /// Call the "Subscribe" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Bidirectional streaming RPC to subscribe to a Topic. The subscription is pull-based. A client can request
        /// > for more events as it consumes events. This enables a client to handle flow control based on the client's processing speed.
        /// > 
        /// > Typical flow:
        /// > 1. Client requests for X number of events via FetchRequest.
        /// > 2. Server receives request and delivers events until X events are delivered to the client via one or more FetchResponse messages.
        /// > 3. Client consumes the FetchResponse messages as they come.
        /// > 4. Client issues new FetchRequest for Y more number of events. This request can
        /// >    come before the server has delivered the earlier requested X number of events
        /// >    so the client gets a continuous stream of events if any.
        /// > 
        /// > If a client requests more events before the server finishes the last
        /// > requested amount, the server appends the new amount to the current amount of
        /// > events it still needs to fetch and deliver.
        /// > 
        /// > A client can subscribe at any point in the stream by providing a replay option in the first FetchRequest.
        /// > The replay option is honored for the first FetchRequest received from a client. Any subsequent FetchRequests with a
        /// > new replay option are ignored. A client needs to call the Subscribe RPC again to restart the subscription
        /// > at a new point in the stream.
        /// > 
        /// > The first FetchRequest of the stream identifies the topic to subscribe to.
        /// > If any subsequent FetchRequest provides topic_name, it must match what
        /// > was provided in the first FetchRequest; otherwise, the RPC returns an error
        /// > with INVALID_ARGUMENT status.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_FetchRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_FetchRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_FetchResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func subscribe<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_FetchRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_FetchRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_FetchResponse>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_FetchResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "GetSchema" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > Get the event schema for a topic based on a schema ID.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_SchemaRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_SchemaRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_SchemaInfo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func getSchema<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_SchemaRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_SchemaRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_SchemaInfo>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_SchemaInfo>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "GetTopic" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Get the topic Information related to the specified topic.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_TopicRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_TopicRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_TopicInfo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func getTopic<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_TopicRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_TopicRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_TopicInfo>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_TopicInfo>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "Publish" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Send a publish request to synchronously publish events to a topic.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_PublishRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_PublishRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_PublishResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func publish<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_PublishRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_PublishRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_PublishResponse>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "PublishStream" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Bidirectional Streaming RPC to publish events to the event bus.
        /// > PublishRequest contains the batch of events to publish.
        /// > 
        /// > The first PublishRequest of the stream identifies the topic to publish on.
        /// > If any subsequent PublishRequest provides topic_name, it must match what
        /// > was provided in the first PublishRequest; otherwise, the RPC returns an error
        /// > with INVALID_ARGUMENT status.
        /// > 
        /// > The server returns a PublishResponse for each PublishRequest when publish is
        /// > complete for the batch. A client does not have to wait for a PublishResponse
        /// > before sending a new PublishRequest, i.e. multiple publish batches can be queued
        /// > up, which allows for higher publish rate as a client can asynchronously
        /// > publish more events while publishes are still in flight on the server side.
        /// > 
        /// > PublishResponse holds a PublishResult for each event published that indicates success
        /// > or failure of the publish. A client can then retry the publish as needed before sending
        /// > more PublishRequests for new events to publish.
        /// > 
        /// > A client must send a valid publish request with one or more events every 70 seconds to hold on to the stream.
        /// > Otherwise, the server closes the stream and notifies the client. Once the client is notified of the stream closure,
        /// > it must make a new PublishStream call to resume publishing.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_PublishRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_PublishRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_PublishResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func publishStream<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_PublishRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_PublishRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_PublishResponse>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable

        /// Call the "ManagedSubscribe" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > This feature is part of an open beta release and is subject to the applicable
        /// > Beta Services Terms provided at Agreements and Terms
        /// > (https://www.salesforce.com/company/legal/agreements/).
        /// > 
        /// > Same as Subscribe, but for Managed Subscription clients.
        /// > This feature is part of an open beta release.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_ManagedFetchRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_ManagedFetchRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_ManagedFetchResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        func managedSubscribe<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_ManagedFetchRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_ManagedFetchRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_ManagedFetchResponse>,
            options: GRPCCore.CallOptions,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_ManagedFetchResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable
    }

    /// Generated client for the "eventbus.v1.PubSub" service.
    ///
    /// The ``Client`` provides an implementation of ``ClientProtocol`` which wraps
    /// a `GRPCCore.GRPCCClient`. The underlying `GRPCClient` provides the long-lived
    /// means of communication with the remote peer.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > The Pub/Sub API provides a single interface for publishing and subscribing to platform events, including real-time
    /// > event monitoring events, and change data capture events. The Pub/Sub API is a gRPC API that is based on HTTP/2.
    /// > 
    /// > A session token is needed to authenticate. Any of the Salesforce supported
    /// > OAuth flows can be used to obtain a session token:
    /// > https://help.salesforce.com/articleView?id=sf.remoteaccess_oauth_flows.htm&type=5
    /// > 
    /// > For each RPC, a client needs to pass authentication information
    /// > as metadata headers (https://www.grpc.io/docs/guides/concepts/#metadata) with their method call.
    /// > 
    /// > For Salesforce session token authentication, use:
    /// >   accesstoken : access token
    /// >   instanceurl : Salesforce instance URL
    /// >   tenantid : tenant/org id of the client
    /// > 
    /// > StatusException is thrown in case of response failure for any request.
    internal struct Client<Transport>: ClientProtocol where Transport: GRPCCore.ClientTransport {
        private let client: GRPCCore.GRPCClient<Transport>

        /// Creates a new client wrapping the provided `GRPCCore.GRPCClient`.
        ///
        /// - Parameters:
        ///   - client: A `GRPCCore.GRPCClient` providing a communication channel to the service.
        internal init(wrapping client: GRPCCore.GRPCClient<Transport>) {
            self.client = client
        }

        /// Call the "Subscribe" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Bidirectional streaming RPC to subscribe to a Topic. The subscription is pull-based. A client can request
        /// > for more events as it consumes events. This enables a client to handle flow control based on the client's processing speed.
        /// > 
        /// > Typical flow:
        /// > 1. Client requests for X number of events via FetchRequest.
        /// > 2. Server receives request and delivers events until X events are delivered to the client via one or more FetchResponse messages.
        /// > 3. Client consumes the FetchResponse messages as they come.
        /// > 4. Client issues new FetchRequest for Y more number of events. This request can
        /// >    come before the server has delivered the earlier requested X number of events
        /// >    so the client gets a continuous stream of events if any.
        /// > 
        /// > If a client requests more events before the server finishes the last
        /// > requested amount, the server appends the new amount to the current amount of
        /// > events it still needs to fetch and deliver.
        /// > 
        /// > A client can subscribe at any point in the stream by providing a replay option in the first FetchRequest.
        /// > The replay option is honored for the first FetchRequest received from a client. Any subsequent FetchRequests with a
        /// > new replay option are ignored. A client needs to call the Subscribe RPC again to restart the subscription
        /// > at a new point in the stream.
        /// > 
        /// > The first FetchRequest of the stream identifies the topic to subscribe to.
        /// > If any subsequent FetchRequest provides topic_name, it must match what
        /// > was provided in the first FetchRequest; otherwise, the RPC returns an error
        /// > with INVALID_ARGUMENT status.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_FetchRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_FetchRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_FetchResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func subscribe<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_FetchRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_FetchRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_FetchResponse>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_FetchResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable {
            try await self.client.bidirectionalStreaming(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.Subscribe.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "GetSchema" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > Get the event schema for a topic based on a schema ID.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_SchemaRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_SchemaRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_SchemaInfo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func getSchema<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_SchemaRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_SchemaRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_SchemaInfo>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_SchemaInfo>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.GetSchema.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "GetTopic" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Get the topic Information related to the specified topic.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_TopicRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_TopicRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_TopicInfo` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func getTopic<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_TopicRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_TopicRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_TopicInfo>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_TopicInfo>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.GetTopic.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "Publish" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Send a publish request to synchronously publish events to a topic.
        ///
        /// - Parameters:
        ///   - request: A request containing a single `Eventbus_V1_PublishRequest` message.
        ///   - serializer: A serializer for `Eventbus_V1_PublishRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_PublishResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func publish<Result>(
            request: GRPCCore.ClientRequest<Eventbus_V1_PublishRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_PublishRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_PublishResponse>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result = { response in
                try response.message
            }
        ) async throws -> Result where Result: Sendable {
            try await self.client.unary(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.Publish.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "PublishStream" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > Bidirectional Streaming RPC to publish events to the event bus.
        /// > PublishRequest contains the batch of events to publish.
        /// > 
        /// > The first PublishRequest of the stream identifies the topic to publish on.
        /// > If any subsequent PublishRequest provides topic_name, it must match what
        /// > was provided in the first PublishRequest; otherwise, the RPC returns an error
        /// > with INVALID_ARGUMENT status.
        /// > 
        /// > The server returns a PublishResponse for each PublishRequest when publish is
        /// > complete for the batch. A client does not have to wait for a PublishResponse
        /// > before sending a new PublishRequest, i.e. multiple publish batches can be queued
        /// > up, which allows for higher publish rate as a client can asynchronously
        /// > publish more events while publishes are still in flight on the server side.
        /// > 
        /// > PublishResponse holds a PublishResult for each event published that indicates success
        /// > or failure of the publish. A client can then retry the publish as needed before sending
        /// > more PublishRequests for new events to publish.
        /// > 
        /// > A client must send a valid publish request with one or more events every 70 seconds to hold on to the stream.
        /// > Otherwise, the server closes the stream and notifies the client. Once the client is notified of the stream closure,
        /// > it must make a new PublishStream call to resume publishing.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_PublishRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_PublishRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_PublishResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func publishStream<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_PublishRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_PublishRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_PublishResponse>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable {
            try await self.client.bidirectionalStreaming(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.PublishStream.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }

        /// Call the "ManagedSubscribe" method.
        ///
        /// > Source IDL Documentation:
        /// >
        /// > 
        /// > This feature is part of an open beta release and is subject to the applicable
        /// > Beta Services Terms provided at Agreements and Terms
        /// > (https://www.salesforce.com/company/legal/agreements/).
        /// > 
        /// > Same as Subscribe, but for Managed Subscription clients.
        /// > This feature is part of an open beta release.
        ///
        /// - Parameters:
        ///   - request: A streaming request producing `Eventbus_V1_ManagedFetchRequest` messages.
        ///   - serializer: A serializer for `Eventbus_V1_ManagedFetchRequest` messages.
        ///   - deserializer: A deserializer for `Eventbus_V1_ManagedFetchResponse` messages.
        ///   - options: Options to apply to this RPC.
        ///   - handleResponse: A closure which handles the response, the result of which is
        ///       returned to the caller. Returning from the closure will cancel the RPC if it
        ///       hasn't already finished.
        /// - Returns: The result of `handleResponse`.
        internal func managedSubscribe<Result>(
            request: GRPCCore.StreamingClientRequest<Eventbus_V1_ManagedFetchRequest>,
            serializer: some GRPCCore.MessageSerializer<Eventbus_V1_ManagedFetchRequest>,
            deserializer: some GRPCCore.MessageDeserializer<Eventbus_V1_ManagedFetchResponse>,
            options: GRPCCore.CallOptions = .defaults,
            onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_ManagedFetchResponse>) async throws -> Result
        ) async throws -> Result where Result: Sendable {
            try await self.client.bidirectionalStreaming(
                request: request,
                descriptor: Eventbus_V1_PubSub.Method.ManagedSubscribe.descriptor,
                serializer: serializer,
                deserializer: deserializer,
                options: options,
                onResponse: handleResponse
            )
        }
    }
}

// Helpers providing default arguments to 'ClientProtocol' methods.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Eventbus_V1_PubSub.ClientProtocol {
    /// Call the "Subscribe" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Bidirectional streaming RPC to subscribe to a Topic. The subscription is pull-based. A client can request
    /// > for more events as it consumes events. This enables a client to handle flow control based on the client's processing speed.
    /// > 
    /// > Typical flow:
    /// > 1. Client requests for X number of events via FetchRequest.
    /// > 2. Server receives request and delivers events until X events are delivered to the client via one or more FetchResponse messages.
    /// > 3. Client consumes the FetchResponse messages as they come.
    /// > 4. Client issues new FetchRequest for Y more number of events. This request can
    /// >    come before the server has delivered the earlier requested X number of events
    /// >    so the client gets a continuous stream of events if any.
    /// > 
    /// > If a client requests more events before the server finishes the last
    /// > requested amount, the server appends the new amount to the current amount of
    /// > events it still needs to fetch and deliver.
    /// > 
    /// > A client can subscribe at any point in the stream by providing a replay option in the first FetchRequest.
    /// > The replay option is honored for the first FetchRequest received from a client. Any subsequent FetchRequests with a
    /// > new replay option are ignored. A client needs to call the Subscribe RPC again to restart the subscription
    /// > at a new point in the stream.
    /// > 
    /// > The first FetchRequest of the stream identifies the topic to subscribe to.
    /// > If any subsequent FetchRequest provides topic_name, it must match what
    /// > was provided in the first FetchRequest; otherwise, the RPC returns an error
    /// > with INVALID_ARGUMENT status.
    ///
    /// - Parameters:
    ///   - request: A streaming request producing `Eventbus_V1_FetchRequest` messages.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func subscribe<Result>(
        request: GRPCCore.StreamingClientRequest<Eventbus_V1_FetchRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_FetchResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        try await self.subscribe(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_FetchRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_FetchResponse>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "GetSchema" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > Get the event schema for a topic based on a schema ID.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Eventbus_V1_SchemaRequest` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func getSchema<Result>(
        request: GRPCCore.ClientRequest<Eventbus_V1_SchemaRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_SchemaInfo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.getSchema(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_SchemaRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_SchemaInfo>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "GetTopic" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Get the topic Information related to the specified topic.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Eventbus_V1_TopicRequest` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func getTopic<Result>(
        request: GRPCCore.ClientRequest<Eventbus_V1_TopicRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_TopicInfo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.getTopic(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_TopicRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_TopicInfo>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "Publish" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Send a publish request to synchronously publish events to a topic.
    ///
    /// - Parameters:
    ///   - request: A request containing a single `Eventbus_V1_PublishRequest` message.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func publish<Result>(
        request: GRPCCore.ClientRequest<Eventbus_V1_PublishRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        try await self.publish(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_PublishRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_PublishResponse>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "PublishStream" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Bidirectional Streaming RPC to publish events to the event bus.
    /// > PublishRequest contains the batch of events to publish.
    /// > 
    /// > The first PublishRequest of the stream identifies the topic to publish on.
    /// > If any subsequent PublishRequest provides topic_name, it must match what
    /// > was provided in the first PublishRequest; otherwise, the RPC returns an error
    /// > with INVALID_ARGUMENT status.
    /// > 
    /// > The server returns a PublishResponse for each PublishRequest when publish is
    /// > complete for the batch. A client does not have to wait for a PublishResponse
    /// > before sending a new PublishRequest, i.e. multiple publish batches can be queued
    /// > up, which allows for higher publish rate as a client can asynchronously
    /// > publish more events while publishes are still in flight on the server side.
    /// > 
    /// > PublishResponse holds a PublishResult for each event published that indicates success
    /// > or failure of the publish. A client can then retry the publish as needed before sending
    /// > more PublishRequests for new events to publish.
    /// > 
    /// > A client must send a valid publish request with one or more events every 70 seconds to hold on to the stream.
    /// > Otherwise, the server closes the stream and notifies the client. Once the client is notified of the stream closure,
    /// > it must make a new PublishStream call to resume publishing.
    ///
    /// - Parameters:
    ///   - request: A streaming request producing `Eventbus_V1_PublishRequest` messages.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func publishStream<Result>(
        request: GRPCCore.StreamingClientRequest<Eventbus_V1_PublishRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        try await self.publishStream(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_PublishRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_PublishResponse>(),
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "ManagedSubscribe" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > This feature is part of an open beta release and is subject to the applicable
    /// > Beta Services Terms provided at Agreements and Terms
    /// > (https://www.salesforce.com/company/legal/agreements/).
    /// > 
    /// > Same as Subscribe, but for Managed Subscription clients.
    /// > This feature is part of an open beta release.
    ///
    /// - Parameters:
    ///   - request: A streaming request producing `Eventbus_V1_ManagedFetchRequest` messages.
    ///   - options: Options to apply to this RPC.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func managedSubscribe<Result>(
        request: GRPCCore.StreamingClientRequest<Eventbus_V1_ManagedFetchRequest>,
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_ManagedFetchResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        try await self.managedSubscribe(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Eventbus_V1_ManagedFetchRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Eventbus_V1_ManagedFetchResponse>(),
            options: options,
            onResponse: handleResponse
        )
    }
}

// Helpers providing sugared APIs for 'ClientProtocol' methods.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Eventbus_V1_PubSub.ClientProtocol {
    /// Call the "Subscribe" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Bidirectional streaming RPC to subscribe to a Topic. The subscription is pull-based. A client can request
    /// > for more events as it consumes events. This enables a client to handle flow control based on the client's processing speed.
    /// > 
    /// > Typical flow:
    /// > 1. Client requests for X number of events via FetchRequest.
    /// > 2. Server receives request and delivers events until X events are delivered to the client via one or more FetchResponse messages.
    /// > 3. Client consumes the FetchResponse messages as they come.
    /// > 4. Client issues new FetchRequest for Y more number of events. This request can
    /// >    come before the server has delivered the earlier requested X number of events
    /// >    so the client gets a continuous stream of events if any.
    /// > 
    /// > If a client requests more events before the server finishes the last
    /// > requested amount, the server appends the new amount to the current amount of
    /// > events it still needs to fetch and deliver.
    /// > 
    /// > A client can subscribe at any point in the stream by providing a replay option in the first FetchRequest.
    /// > The replay option is honored for the first FetchRequest received from a client. Any subsequent FetchRequests with a
    /// > new replay option are ignored. A client needs to call the Subscribe RPC again to restart the subscription
    /// > at a new point in the stream.
    /// > 
    /// > The first FetchRequest of the stream identifies the topic to subscribe to.
    /// > If any subsequent FetchRequest provides topic_name, it must match what
    /// > was provided in the first FetchRequest; otherwise, the RPC returns an error
    /// > with INVALID_ARGUMENT status.
    ///
    /// - Parameters:
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - producer: A closure producing request messages to send to the server. The request
    ///       stream is closed when the closure returns.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func subscribe<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer producer: @Sendable @escaping (GRPCCore.RPCWriter<Eventbus_V1_FetchRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_FetchResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.StreamingClientRequest<Eventbus_V1_FetchRequest>(
            metadata: metadata,
            producer: producer
        )
        return try await self.subscribe(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "GetSchema" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > Get the event schema for a topic based on a schema ID.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func getSchema<Result>(
        _ message: Eventbus_V1_SchemaRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_SchemaInfo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Eventbus_V1_SchemaRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.getSchema(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "GetTopic" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Get the topic Information related to the specified topic.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func getTopic<Result>(
        _ message: Eventbus_V1_TopicRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_TopicInfo>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Eventbus_V1_TopicRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.getTopic(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "Publish" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Send a publish request to synchronously publish events to a topic.
    ///
    /// - Parameters:
    ///   - message: request message to send.
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func publish<Result>(
        _ message: Eventbus_V1_PublishRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result = { response in
            try response.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest<Eventbus_V1_PublishRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.publish(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "PublishStream" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > Bidirectional Streaming RPC to publish events to the event bus.
    /// > PublishRequest contains the batch of events to publish.
    /// > 
    /// > The first PublishRequest of the stream identifies the topic to publish on.
    /// > If any subsequent PublishRequest provides topic_name, it must match what
    /// > was provided in the first PublishRequest; otherwise, the RPC returns an error
    /// > with INVALID_ARGUMENT status.
    /// > 
    /// > The server returns a PublishResponse for each PublishRequest when publish is
    /// > complete for the batch. A client does not have to wait for a PublishResponse
    /// > before sending a new PublishRequest, i.e. multiple publish batches can be queued
    /// > up, which allows for higher publish rate as a client can asynchronously
    /// > publish more events while publishes are still in flight on the server side.
    /// > 
    /// > PublishResponse holds a PublishResult for each event published that indicates success
    /// > or failure of the publish. A client can then retry the publish as needed before sending
    /// > more PublishRequests for new events to publish.
    /// > 
    /// > A client must send a valid publish request with one or more events every 70 seconds to hold on to the stream.
    /// > Otherwise, the server closes the stream and notifies the client. Once the client is notified of the stream closure,
    /// > it must make a new PublishStream call to resume publishing.
    ///
    /// - Parameters:
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - producer: A closure producing request messages to send to the server. The request
    ///       stream is closed when the closure returns.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func publishStream<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer producer: @Sendable @escaping (GRPCCore.RPCWriter<Eventbus_V1_PublishRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_PublishResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.StreamingClientRequest<Eventbus_V1_PublishRequest>(
            metadata: metadata,
            producer: producer
        )
        return try await self.publishStream(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }

    /// Call the "ManagedSubscribe" method.
    ///
    /// > Source IDL Documentation:
    /// >
    /// > 
    /// > This feature is part of an open beta release and is subject to the applicable
    /// > Beta Services Terms provided at Agreements and Terms
    /// > (https://www.salesforce.com/company/legal/agreements/).
    /// > 
    /// > Same as Subscribe, but for Managed Subscription clients.
    /// > This feature is part of an open beta release.
    ///
    /// - Parameters:
    ///   - metadata: Additional metadata to send, defaults to empty.
    ///   - options: Options to apply to this RPC, defaults to `.defaults`.
    ///   - producer: A closure producing request messages to send to the server. The request
    ///       stream is closed when the closure returns.
    ///   - handleResponse: A closure which handles the response, the result of which is
    ///       returned to the caller. Returning from the closure will cancel the RPC if it
    ///       hasn't already finished.
    /// - Returns: The result of `handleResponse`.
    internal func managedSubscribe<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer producer: @Sendable @escaping (GRPCCore.RPCWriter<Eventbus_V1_ManagedFetchRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.StreamingClientResponse<Eventbus_V1_ManagedFetchResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.StreamingClientRequest<Eventbus_V1_ManagedFetchRequest>(
            metadata: metadata,
            producer: producer
        )
        return try await self.managedSubscribe(
            request: request,
            options: options,
            onResponse: handleResponse
        )
    }
}